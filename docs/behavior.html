<!DOCTYPE html>

<html>
<head>
  <title>behavior.js</title>
  <meta http-equiv="content-type" content="text/html; charset=UTF-8">
  <meta name="viewport" content="width=device-width, target-densitydpi=160dpi, initial-scale=1.0; maximum-scale=1.0; user-scalable=0;">
  <link rel="stylesheet" media="all" href="docco.css" />
</head>
<body>
  <div id="container">
    <div id="background"></div>
    
      <ul id="jump_to">
        <li>
          <a class="large" href="javascript:void(0);">Jump To &hellip;</a>
          <a class="small" href="javascript:void(0);">+</a>
          <div id="jump_wrapper">
          <div id="jump_page">
            
              
              <a class="source" href="behavior.html">
                behavior.js
              </a>
            
              
              <a class="source" href="clock.html">
                clock.js
              </a>
            
              
              <a class="source" href="iteration.html">
                iteration.js
              </a>
            
              
              <a class="source" href="operators.html">
                operators.js
              </a>
            
              
              <a class="source" href="signal.html">
                signal.js
              </a>
            
              
              <a class="source" href="stream.html">
                stream.js
              </a>
            
              
              <a class="source" href="task.html">
                task.js
              </a>
            
          </div>
        </li>
      </ul>
    
    <ul class="sections">
        
          <li id="title">
              <div class="annotation">
                  <h1>behavior.js</h1>
              </div>
          </li>
        
        
        
        <li id="section-1">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-1">&#182;</a>
              </div>
              
            </div>
            
        </li>
        
        
        <li id="section-2">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-2">&#182;</a>
              </div>
              <p>A behavior is a <strong>pull</strong> or <strong>poll</strong> representation of a value that varies
<strong>continuously</strong> over time.
Behaviors only model the <strong>getter</strong> side of the <em>getter, setter, value</em>
triad because they produce the value for any given time on demand.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre><span class="hljs-pi">
"use strict"</span>;

<span class="hljs-keyword">var</span> WeakMap = <span class="hljs-built_in">require</span>(<span class="hljs-string">"collections/weak-map"</span>);
<span class="hljs-keyword">var</span> Operators = <span class="hljs-built_in">require</span>(<span class="hljs-string">"./operators"</span>);
<span class="hljs-keyword">var</span> Iteration = <span class="hljs-built_in">require</span>(<span class="hljs-string">"./iteration"</span>);</pre></div></div>
            
        </li>
        
        
        <li id="section-3">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-3">&#182;</a>
              </div>
              <h3 id="behaviorhandler">BehaviorHandler</h3>

            </div>
            
        </li>
        
        
        <li id="section-4">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-4">&#182;</a>
              </div>
              <p>The private handler for a behavior captures its internal state.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>
<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">BehaviorHandler</span><span class="hljs-params">(callback, thisp)</span> </span>{
    <span class="hljs-keyword">this</span>.callback = callback;
    <span class="hljs-keyword">this</span>.thisp = thisp;
}</pre></div></div>
            
        </li>
        
        
        <li id="section-5">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-5">&#182;</a>
              </div>
              <p>We have to set this up before constructing singleton behaviors.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre><span class="hljs-keyword">var</span> handlers = <span class="hljs-keyword">new</span> WeakMap();</pre></div></div>
            
        </li>
        
        
        <li id="section-6">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-6">&#182;</a>
              </div>
              <h2 id="behavior">Behavior</h2>
<p>The behavior constructor accepts a method and optional context object for
that method.
This method will be polled at each time the behavior is called upon to
produce a new value.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>
<span class="hljs-built_in">module</span>.exports = Behavior;
<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Behavior</span><span class="hljs-params">(callback, thisp)</span> </span>{</pre></div></div>
            
        </li>
        
        
        <li id="section-7">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-7">&#182;</a>
              </div>
              <p>Behaviors use a weak map of hidden records for private state.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>    <span class="hljs-keyword">var</span> handler = <span class="hljs-keyword">new</span> BehaviorHandler(callback, thisp);
    handlers.set(<span class="hljs-keyword">this</span>, handler);
}</pre></div></div>
            
        </li>
        
        
        <li id="section-8">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-8">&#182;</a>
              </div>
              <p>The <code>return</code> static method creates a behavior that provides the given
constant value.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>Behavior.return = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(value)</span> </span>{
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> Behavior(<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">()</span> </span>{
        <span class="hljs-keyword">return</span> value;
    });
};</pre></div></div>
            
        </li>
        
        
        <li id="section-9">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-9">&#182;</a>
              </div>
              <p>The <code>index</code> singleton behavior provides the time or “index” any time it is
polled.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>Behavior.index = <span class="hljs-keyword">new</span> Behavior(<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(index)</span> </span>{
    <span class="hljs-keyword">return</span> index;
});</pre></div></div>
            
        </li>
        
        
        <li id="section-10">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-10">&#182;</a>
              </div>
              <p>The <code>get</code> method of a behavior produces</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>Behavior.prototype.get = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(index)</span> </span>{
    <span class="hljs-keyword">var</span> handler = handlers.get(<span class="hljs-keyword">this</span>);
    <span class="hljs-keyword">return</span> handler.callback.call(handler.thisp, index);
};</pre></div></div>
            
        </li>
        
        
        <li id="section-11">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-11">&#182;</a>
              </div>
              <p>The <code>next</code> method of a behavior returns an iteration that captures both the
value and index time, and gives a behavior the same shape as an iterable.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>Behavior.prototype.next = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(index)</span> </span>{
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> Iteration(<span class="hljs-keyword">this</span>.get(index), <span class="hljs-literal">false</span>, index);
};</pre></div></div>
            
        </li>
        
        
        <li id="section-12">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-12">&#182;</a>
              </div>
              <p>The static <code>lift</code> method accepts an operator and its context object and
produces the analogous operator on behaviors.
The resulting operator accepts and returns behaviors instead of values.
Each time the user polls the returned behavior they will get the result of
applying the current value of each behavior argument to the operator.</p>
<p>For example, <code>Beahavior.lift(add)</code> will produce a <code>behaviorAdd</code> operator.
<code>behaviorAdd(Behavior.return(10), Behavior.return(20))</code> will produce a
behavior that will always yield <code>30</code>.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>Behavior.lift = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(operator, operators)</span> </span>{
    <span class="hljs-keyword">return</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">operatorBehavior</span><span class="hljs-params">()</span> </span>{
        <span class="hljs-keyword">var</span> operands = <span class="hljs-built_in">Array</span>.prototype.slice.call(<span class="hljs-built_in">arguments</span>); <span class="hljs-comment">/* TODO unroll */</span>
        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> Behavior(<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(index)</span> </span>{
            <span class="hljs-keyword">var</span> values = operands.map(<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(operand)</span> </span>{
                <span class="hljs-keyword">return</span> operand.get(index);
            });
            <span class="hljs-keyword">if</span> (values.every(Operators.defined)) {
                <span class="hljs-keyword">return</span> operator.apply(operators, values);
            }
        });
    };
};</pre></div></div>
            
        </li>
        
        
        <li id="section-13">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-13">&#182;</a>
              </div>
              <p>The <code>tupleLift</code> static method is the same as <code>lift</code> accept that the returned
behavior operator accepts an array of behaviors instead of variadic behavior
arguments.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>Behavior.tupleLift = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(operator, operators)</span> </span>{
    <span class="hljs-keyword">return</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">operatorBehavior</span><span class="hljs-params">(operands)</span> </span>{
        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> Behavior(<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(index)</span> </span>{
            <span class="hljs-keyword">var</span> values = operands.map(<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(operand)</span> </span>{
                <span class="hljs-keyword">return</span> operand.get(index);
            });
            <span class="hljs-keyword">if</span> (values.every(Operators.defined)) {
                <span class="hljs-keyword">return</span> operator.apply(operators, values);
            }
        });
    };
};</pre></div></div>
            
        </li>
        
        
        <li id="section-14">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-14">&#182;</a>
              </div>
              <p>Using <code>lift</code> and <code>tupleLift</code>, we generate both a method for both the
behavior constructor and prototype for each of the operators defined in the
<code>Operators</code> module.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre><span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> name <span class="hljs-keyword">in</span> Operators) {
    (<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(operator, name)</span> </span>{
        Behavior[name] = Behavior.lift(operator, Operators);
        <span class="hljs-keyword">var</span> tupleLift = Behavior.tupleLift(operator, Operators);
        Behavior.prototype[name] = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">()</span> </span>{
            <span class="hljs-keyword">var</span> operands = [<span class="hljs-keyword">this</span>];
            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> index = <span class="hljs-number">0</span>; index &lt; <span class="hljs-built_in">arguments</span>.length; index++) {
                operands[index + <span class="hljs-number">1</span>] = <span class="hljs-built_in">arguments</span>[index];
            }
            <span class="hljs-keyword">return</span> tupleLift(operands);
        };
    })(Operators[name], name);
}</pre></div></div>
            
        </li>
        
    </ul>
  </div>
</body>
</html>
